{"version":3,"file":"chartjs-plugin-trendline.min.js","sources":["../src/utils/lineFitter.js","../src/utils/exponentialFitter.js","../src/utils/drawing.js","../src/components/trendline.js","../src/components/label.js","../src/core/plugin.js","../src/index.js"],"sourcesContent":["/**\r\n * A class that fits a line to a series of points using least squares.\r\n */\r\nexport class LineFitter {\r\n    constructor() {\r\n        this.count = 0;\r\n        this.sumx = 0;\r\n        this.sumy = 0;\r\n        this.sumx2 = 0;\r\n        this.sumxy = 0;\r\n        this.minx = Number.MAX_VALUE;\r\n        this.maxx = Number.MIN_VALUE;\r\n        this._cachedSlope = null;\r\n        this._cachedIntercept = null;\r\n        this._cacheValid = false;\r\n    }\r\n\r\n    /**\r\n     * Adds a point to the line fitter.\r\n     * @param {number} x - The x-coordinate of the point.\r\n     * @param {number} y - The y-coordinate of the point.\r\n     */\r\n    add(x, y) {\r\n        this.sumx += x;\r\n        this.sumy += y;\r\n        this.sumx2 += x * x;\r\n        this.sumxy += x * y;\r\n        if (x < this.minx) this.minx = x;\r\n        if (x > this.maxx) this.maxx = x;\r\n        this.count++;\r\n        this._cacheValid = false;\r\n    }\r\n\r\n    /**\r\n     * Calculates the slope of the fitted line.\r\n     * @returns {number} - The slope of the line.\r\n     */\r\n    slope() {\r\n        if (!this._cacheValid) {\r\n            this._computeCoefficients();\r\n        }\r\n        return this._cachedSlope;\r\n    }\r\n\r\n    /**\r\n     * Calculates the y-intercept of the fitted line.\r\n     * @returns {number} - The y-intercept of the line.\r\n     */\r\n    intercept() {\r\n        if (!this._cacheValid) {\r\n            this._computeCoefficients();\r\n        }\r\n        return this._cachedIntercept;\r\n    }\r\n\r\n    /**\r\n     * Returns the fitted value (y) for a given x.\r\n     * @param {number} x - The x-coordinate.\r\n     * @returns {number} - The corresponding y-coordinate on the fitted line.\r\n     */\r\n    f(x) {\r\n        return this.slope() * x + this.intercept();\r\n    }\r\n\r\n    /**\r\n     * Calculates the projection of the line for the future value.\r\n     * @returns {number} - The future value based on the fitted line.\r\n     */\r\n    fo() {\r\n        return -this.intercept() / this.slope();\r\n    }\r\n\r\n    /**\r\n     * Returns the scale (variance) of the fitted line.\r\n     * @returns {number} - The scale of the fitted line.\r\n     */\r\n    scale() {\r\n        return this.slope();\r\n    }\r\n\r\n    _computeCoefficients() {\r\n        const denominator = this.count * this.sumx2 - this.sumx * this.sumx;\r\n        this._cachedSlope = (this.count * this.sumxy - this.sumx * this.sumy) / denominator;\r\n        this._cachedIntercept = (this.sumy - this._cachedSlope * this.sumx) / this.count;\r\n        this._cacheValid = true;\r\n    }\r\n} ","/**\r\n * A class that fits an exponential curve to a series of points using least squares.\r\n * Fits y = a * e^(b*x) by transforming to ln(y) = ln(a) + b*x\r\n */\r\nexport class ExponentialFitter {\r\n    constructor() {\r\n        this.count = 0;\r\n        this.sumx = 0;\r\n        this.sumlny = 0;\r\n        this.sumx2 = 0;\r\n        this.sumxlny = 0;\r\n        this.minx = Number.MAX_VALUE;\r\n        this.maxx = Number.MIN_VALUE;\r\n        this.hasValidData = true;\r\n        this.dataPoints = []; // Store data points for correlation calculation\r\n        this._cachedGrowthRate = null;\r\n        this._cachedCoefficient = null;\r\n        this._cachedCorrelation = null;\r\n        this._cacheValid = false;\r\n    }\r\n\r\n    /**\r\n     * Adds a point to the exponential fitter.\r\n     * @param {number} x - The x-coordinate of the point.\r\n     * @param {number} y - The y-coordinate of the point.\r\n     */\r\n    add(x, y) {\r\n        if (y <= 0) {\r\n            this.hasValidData = false;\r\n            return;\r\n        }\r\n\r\n        const lny = Math.log(y);\r\n        if (!isFinite(lny)) {\r\n            this.hasValidData = false;\r\n            return;\r\n        }\r\n\r\n        this.sumx += x;\r\n        this.sumlny += lny;\r\n        this.sumx2 += x * x;\r\n        this.sumxlny += x * lny;\r\n        if (x < this.minx) this.minx = x;\r\n        if (x > this.maxx) this.maxx = x;\r\n        this.dataPoints.push({x, y, lny}); // Store actual data points\r\n        this.count++;\r\n        this._cacheValid = false;\r\n    }\r\n\r\n    /**\r\n     * Calculates the exponential growth rate (b in y = a * e^(b*x)).\r\n     * @returns {number} - The exponential growth rate.\r\n     */\r\n    growthRate() {\r\n        if (!this.hasValidData || this.count < 2) return 0;\r\n        if (!this._cacheValid) {\r\n            this._computeCoefficients();\r\n        }\r\n        return this._cachedGrowthRate;\r\n    }\r\n\r\n    /**\r\n     * Calculates the exponential coefficient (a in y = a * e^(b*x)).\r\n     * @returns {number} - The exponential coefficient.\r\n     */\r\n    coefficient() {\r\n        if (!this.hasValidData || this.count < 2) return 1;\r\n        if (!this._cacheValid) {\r\n            this._computeCoefficients();\r\n        }\r\n        return this._cachedCoefficient;\r\n    }\r\n\r\n    /**\r\n     * Returns the fitted exponential value (y) for a given x.\r\n     * @param {number} x - The x-coordinate.\r\n     * @returns {number} - The corresponding y-coordinate on the fitted exponential curve.\r\n     */\r\n    f(x) {\r\n        if (!this.hasValidData || this.count < 2) return 0;\r\n        if (!this._cacheValid) {\r\n            this._computeCoefficients();\r\n        }\r\n        \r\n        // Check for potential overflow before calculation\r\n        if (Math.abs(this._cachedGrowthRate * x) > 500) return 0; // Safer limit to prevent overflow\r\n        \r\n        const result = this._cachedCoefficient * Math.exp(this._cachedGrowthRate * x);\r\n        return isFinite(result) ? result : 0;\r\n    }\r\n\r\n    /**\r\n     * Calculates the correlation coefficient (R-squared) for the exponential fit.\r\n     * @returns {number} - The correlation coefficient (0-1).\r\n     */\r\n    correlation() {\r\n        if (!this.hasValidData || this.count < 2) return 0;\r\n        if (!this._cacheValid) {\r\n            this._computeCoefficients();\r\n        }\r\n        return this._cachedCorrelation;\r\n    }\r\n\r\n    /**\r\n     * Returns the scale (growth rate) of the fitted exponential curve.\r\n     * @returns {number} - The growth rate of the exponential curve.\r\n     */\r\n    scale() {\r\n        return this.growthRate();\r\n    }\r\n\r\n    _computeCoefficients() {\r\n        if (!this.hasValidData || this.count < 2) {\r\n            this._cachedGrowthRate = 0;\r\n            this._cachedCoefficient = 1;\r\n            this._cachedCorrelation = 0;\r\n            this._cacheValid = true;\r\n            return;\r\n        }\r\n\r\n        const denominator = this.count * this.sumx2 - this.sumx * this.sumx;\r\n        if (Math.abs(denominator) < 1e-10) {\r\n            this._cachedGrowthRate = 0;\r\n            this._cachedCoefficient = 1;\r\n            this._cachedCorrelation = 0;\r\n            this._cacheValid = true;\r\n            return;\r\n        }\r\n\r\n        this._cachedGrowthRate = (this.count * this.sumxlny - this.sumx * this.sumlny) / denominator;\r\n        const lnA = (this.sumlny - this._cachedGrowthRate * this.sumx) / this.count;\r\n        this._cachedCoefficient = Math.exp(lnA);\r\n\r\n        const meanLnY = this.sumlny / this.count;\r\n        let ssTotal = 0;\r\n        let ssRes = 0;\r\n        \r\n        for (const point of this.dataPoints) {\r\n            const predictedLnY = lnA + this._cachedGrowthRate * point.x;\r\n            ssTotal += Math.pow(point.lny - meanLnY, 2);\r\n            ssRes += Math.pow(point.lny - predictedLnY, 2);\r\n        }\r\n        \r\n        this._cachedCorrelation = ssTotal === 0 ? 1 : Math.max(0, 1 - (ssRes / ssTotal));\r\n        this._cacheValid = true;\r\n    }\r\n}","/**\r\n * Retrieves the x and y scales from the chart instance.\r\n * @param {Chart} chartInstance - The chart instance.\r\n * @returns {Object} - The xScale and yScale of the chart.\r\n */\r\nexport const getScales = (chartInstance) => {\r\n    let xScale, yScale;\r\n    for (const scale of Object.values(chartInstance.scales)) {\r\n        if (scale.isHorizontal()) xScale = scale;\r\n        else yScale = scale;\r\n        if (xScale && yScale) break;\r\n    }\r\n    return { xScale, yScale };\r\n};\r\n\r\n/**\r\n * Sets the line style (dashed, dotted, solid) for the canvas context.\r\n * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.\r\n * @param {string} lineStyle - The style of the line ('dotted', 'dashed', 'solid', etc.).\r\n */\r\nexport const setLineStyle = (ctx, lineStyle) => {\r\n    switch (lineStyle) {\r\n        case 'dotted':\r\n            ctx.setLineDash([2, 2]);\r\n            break;\r\n        case 'dashed':\r\n            ctx.setLineDash([8, 3]);\r\n            break;\r\n        case 'dashdot':\r\n            ctx.setLineDash([8, 3, 2, 3]);\r\n            break;\r\n        case 'solid':\r\n        default:\r\n            ctx.setLineDash([]);\r\n            break;\r\n    }\r\n};\r\n\r\n/**\r\n * Draws the trendline on the canvas context.\r\n * @param {Object} params - The trendline parameters.\r\n * @param {CanvasRenderingContext2D} params.ctx - The canvas rendering context.\r\n * @param {number} params.x1 - Starting x-coordinate of the trendline.\r\n * @param {number} params.y1 - Starting y-coordinate of the trendline.\r\n * @param {number} params.x2 - Ending x-coordinate of the trendline.\r\n * @param {number} params.y2 - Ending y-coordinate of the trendline.\r\n * @param {string} params.colorMin - The starting color of the trendline gradient.\r\n * @param {string} params.colorMax - The ending color of the trendline gradient.\r\n */\r\nexport const drawTrendline = ({ ctx, x1, y1, x2, y2, colorMin, colorMax }) => {\r\n    // Ensure all values are finite numbers\r\n    if (!isFinite(x1) || !isFinite(y1) || !isFinite(x2) || !isFinite(y2)) {\r\n        console.warn(\r\n            'Cannot draw trendline: coordinates contain non-finite values',\r\n            { x1, y1, x2, y2 }\r\n        );\r\n        return;\r\n    }\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(x1, y1);\r\n    ctx.lineTo(x2, y2);\r\n\r\n    try {\r\n        // Additional validation for degenerate gradients\r\n        const dx = x2 - x1;\r\n        const dy = y2 - y1;\r\n        const gradientLength = Math.sqrt(dx * dx + dy * dy);\r\n        \r\n        // If the gradient vector is too small, createLinearGradient may fail\r\n        if (gradientLength < 0.01) {\r\n            console.warn('Gradient vector too small, using solid color:', { x1, y1, x2, y2, length: gradientLength });\r\n            ctx.strokeStyle = colorMin;\r\n        } else {\r\n            let gradient = ctx.createLinearGradient(x1, y1, x2, y2);\r\n            gradient.addColorStop(0, colorMin);\r\n            gradient.addColorStop(1, colorMax);\r\n            ctx.strokeStyle = gradient;\r\n        }\r\n    } catch (e) {\r\n        // Fallback to solid color if gradient creation fails\r\n        console.warn('Gradient creation failed, using solid color:', e);\r\n        ctx.strokeStyle = colorMin;\r\n    }\r\n\r\n    ctx.stroke();\r\n    ctx.closePath();\r\n};\r\n\r\n/**\r\n * Fills the area below the trendline with the specified color.\r\n * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.\r\n * @param {number} x1 - Starting x-coordinate of the trendline.\r\n * @param {number} y1 - Starting y-coordinate of the trendline.\r\n * @param {number} x2 - Ending x-coordinate of the trendline.\r\n * @param {number} y2 - Ending y-coordinate of the trendline.\r\n * @param {number} drawBottom - The bottom boundary of the chart.\r\n * @param {string} fillColor - The color to fill below the trendline.\r\n */\r\nexport const fillBelowTrendline = (ctx, x1, y1, x2, y2, drawBottom, fillColor) => {\r\n    // Ensure all values are finite numbers\r\n    if (\r\n        !isFinite(x1) ||\r\n        !isFinite(y1) ||\r\n        !isFinite(x2) ||\r\n        !isFinite(y2) ||\r\n        !isFinite(drawBottom)\r\n    ) {\r\n        console.warn(\r\n            'Cannot fill below trendline: coordinates contain non-finite values',\r\n            { x1, y1, x2, y2, drawBottom }\r\n        );\r\n        return;\r\n    }\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(x1, y1);\r\n    ctx.lineTo(x2, y2);\r\n    ctx.lineTo(x2, drawBottom);\r\n    ctx.lineTo(x1, drawBottom);\r\n    ctx.lineTo(x1, y1);\r\n    ctx.closePath();\r\n\r\n    ctx.fillStyle = fillColor;\r\n    ctx.fill();\r\n}; ","import { LineFitter } from '../utils/lineFitter.js';\r\nimport { ExponentialFitter } from '../utils/exponentialFitter.js';\r\nimport { drawTrendline, fillBelowTrendline, setLineStyle } from '../utils/drawing.js';\r\nimport { addTrendlineLabel } from './label.js';\r\n\r\n/**\r\n * Adds a trendline (fitter) to the dataset on the chart and optionally labels it with trend value.\r\n * @param {Object} datasetMeta - Metadata about the dataset.\r\n * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.\r\n * @param {Object} dataset - The dataset configuration from the chart.\r\n * @param {Scale} xScale - The x-axis scale object.\r\n * @param {Scale} yScale - The y-axis scale object.\r\n */\r\nexport const addFitter = (datasetMeta, ctx, dataset, xScale, yScale) => {\r\n    const yAxisID = dataset.yAxisID || 'y'; // Default to 'y' if no yAxisID is specified\r\n    const yScaleToUse = datasetMeta.controller.chart.scales[yAxisID] || yScale;\r\n\r\n    // Determine if we're using exponential or linear trendline\r\n    const isExponential = !!dataset.trendlineExponential;\r\n    const trendlineConfig = dataset.trendlineExponential || dataset.trendlineLinear || {};\r\n\r\n    const defaultColor = dataset.borderColor || 'rgba(169,169,169, .6)';\r\n    const {\r\n        colorMin = defaultColor,\r\n        colorMax = defaultColor,\r\n        width: lineWidth = dataset.borderWidth || 3,\r\n        lineStyle = 'solid',\r\n        fillColor = false,\r\n        // trendoffset is now handled separately\r\n    } = trendlineConfig;\r\n    let trendoffset = trendlineConfig.trendoffset || 0;\r\n\r\n    const {\r\n        color = defaultColor,\r\n        text = isExponential ? 'Exponential Trendline' : 'Trendline',\r\n        display = true,\r\n        displayValue = true,\r\n        offset = 10,\r\n        percentage = false,\r\n    } = (trendlineConfig && trendlineConfig.label) || {};\r\n\r\n    const {\r\n        family = \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\r\n        size = 12,\r\n    } = (trendlineConfig && trendlineConfig.label && trendlineConfig.label.font) || {};\r\n\r\n    const chartOptions = datasetMeta.controller.chart.options;\r\n    const parsingOptions =\r\n        typeof chartOptions.parsing === 'object'\r\n            ? chartOptions.parsing\r\n            : undefined;\r\n    const xAxisKey =\r\n        trendlineConfig?.xAxisKey || parsingOptions?.xAxisKey || 'x';\r\n    const yAxisKey =\r\n        trendlineConfig?.yAxisKey || parsingOptions?.yAxisKey || 'y';\r\n\r\n    let fitter = isExponential ? new ExponentialFitter() : new LineFitter();\r\n    \r\n    // --- Data Point Collection and Validation for LineFitter ---\r\n\r\n    // Sanitize trendoffset: if its absolute value is too large, reset to 0.\r\n    // This prevents errors if offset is out of bounds of the dataset length.\r\n    if (Math.abs(trendoffset) >= dataset.data.length) trendoffset = 0;\r\n    \r\n    // Determine the actual starting index for data processing if a positive trendoffset is applied.\r\n    // This skips initial data points and finds the first non-null data point thereafter.\r\n    // `effectiveFirstIndex` is used to determine the data type ('xy' or array) and to skip initial points for positive offset.\r\n    let effectiveFirstIndex = 0;\r\n    if (trendoffset > 0) {\r\n        // Start searching for a non-null point from the offset.\r\n        const firstNonNullAfterOffset = dataset.data.slice(trendoffset).findIndex((d) => d !== undefined && d !== null);\r\n        if (firstNonNullAfterOffset !== -1) {\r\n            effectiveFirstIndex = trendoffset + firstNonNullAfterOffset;\r\n        } else {\r\n            // All points after the offset are null or undefined, so effectively no data for trendline.\r\n            effectiveFirstIndex = dataset.data.length; \r\n        }\r\n    } else {\r\n        // For zero or negative offset, the initial search for 'xy' type detection starts from the beginning of the dataset.\r\n        // The actual exclusion of points for negative offset (from the end) is handled per-point within the loop.\r\n        const firstNonNull = dataset.data.findIndex((d) => d !== undefined && d !== null);\r\n        if (firstNonNull !== -1) {\r\n            effectiveFirstIndex = firstNonNull;\r\n        } else {\r\n            // All data in the dataset is null or undefined.\r\n            effectiveFirstIndex = dataset.data.length; \r\n        }\r\n    }\r\n    \r\n    // Determine data structure type (object {x,y} or array of numbers) based on the first valid data point.\r\n    // This informs how `xAxisKey` and `yAxisKey` are used or if `index` is used for x-values.\r\n    let xy = effectiveFirstIndex < dataset.data.length && typeof dataset.data[effectiveFirstIndex] === 'object';\r\n\r\n    // Iterate over dataset to collect points for the LineFitter.\r\n    dataset.data.forEach((data, index) => {\r\n        // Skip any data point that is null or undefined directly. This is a general guard.\r\n        if (data == null) return; \r\n        \r\n        // Apply trendoffset logic for including/excluding points:\r\n        // 1. Positive offset: Skip data points if their index is before the `effectiveFirstIndex`.\r\n        //    `effectiveFirstIndex` already accounts for the offset and initial nulls.\r\n        if (trendoffset > 0 && index < effectiveFirstIndex) return;\r\n        // 2. Negative offset: Skip data points if their index is at or after the calculated end point.\r\n        //    `dataset.data.length + trendoffset` marks the first index of the points to be excluded from the end.\r\n        //    For example, if length is 10 and offset is -2, points from index 8 onwards are skipped.\r\n        if (trendoffset < 0 && index >= dataset.data.length + trendoffset) return;\r\n\r\n        // Process data based on scale type and data structure.\r\n        if (['time', 'timeseries'].includes(xScale.options.type) && xy) {\r\n            // For time-based scales with object data, convert x to a numerical timestamp; ensure y is a valid number.\r\n            let x = data[xAxisKey] != null ? data[xAxisKey] : data.t; // `data.t` is a Chart.js internal fallback for time data.\r\n            const yValue = data[yAxisKey];\r\n\r\n            // Both x and y must be valid for the point to be included.\r\n            if (x != null && x !== undefined && yValue != null && !isNaN(yValue)) {\r\n                fitter.add(new Date(x).getTime(), yValue);\r\n            }\r\n            // If x or yValue is invalid, the point is skipped.\r\n        } else if (xy) { // Data is identified as array of objects {x,y}.\r\n            const xVal = data[xAxisKey];\r\n            const yVal = data[yAxisKey];\r\n\r\n            const xIsValid = xVal != null && !isNaN(xVal);\r\n            const yIsValid = yVal != null && !isNaN(yVal);\r\n\r\n            // Both xVal and yVal must be valid numbers to include the point.\r\n            if (xIsValid && yIsValid) {\r\n                fitter.add(xVal, yVal);\r\n            }\r\n            // If either xVal or yVal is invalid, the point is skipped. No fallback to using index.\r\n        } else if (['time', 'timeseries'].includes(xScale.options.type) && !xy) {\r\n            // For time-based scales with array of numbers, get the x-value from the chart labels\r\n            const chartLabels = datasetMeta.controller.chart.data.labels;\r\n            if (chartLabels && chartLabels[index] && data != null && !isNaN(data)) {\r\n                const timeValue = new Date(chartLabels[index]).getTime();\r\n                if (!isNaN(timeValue)) {\r\n                    fitter.add(timeValue, data);\r\n                }\r\n            }\r\n        } else { \r\n            // Data is an array of numbers (or other non-object types).\r\n            // The 'data' variable itself is the y-value, and 'index' is the x-value.\r\n            // We still need to check for null/NaN here because 'data' (the y-value) could be null/NaN\r\n            // even if the entry 'data' (the point/container) wasn't null in the initial check.\r\n            // This applies if dataset.data = [1, 2, null, 4].\r\n            if (data != null && !isNaN(data)) {\r\n                 fitter.add(index, data);\r\n            }\r\n        }\r\n    });\r\n\r\n    // --- Trendline Coordinate Calculation ---\r\n    // Ensure there are enough points to form a trendline.\r\n    if (fitter.count < 2) {\r\n        return; // Not enough data points to calculate a trendline.\r\n    }\r\n\r\n    // These variables will hold the pixel coordinates for drawing the trendline.\r\n    let x1_px, y1_px, x2_px, y2_px; \r\n\r\n    const chartArea = datasetMeta.controller.chart.chartArea; // Defines the drawable area in pixels.\r\n\r\n    // Determine trendline start/end points based on the 'projection' option.\r\n    if (trendlineConfig.projection) {\r\n        let points = [];\r\n\r\n        if (isExponential) {\r\n            // For exponential curves, we generate points across the x-axis range\r\n            const val_x_left = xScale.getValueForPixel(chartArea.left);\r\n            const y_at_left = fitter.f(val_x_left); \r\n            points.push({ x: val_x_left, y: y_at_left });\r\n\r\n            const val_x_right = xScale.getValueForPixel(chartArea.right);\r\n            const y_at_right = fitter.f(val_x_right); \r\n            points.push({ x: val_x_right, y: y_at_right });\r\n        } else {\r\n            // Linear projection logic (existing code)\r\n            const slope = fitter.slope();\r\n            const intercept = fitter.intercept();\r\n\r\n            if (Math.abs(slope) > 1e-6) { \r\n                const val_y_top = yScaleToUse.getValueForPixel(chartArea.top);\r\n                const x_at_top = (val_y_top - intercept) / slope; \r\n                points.push({ x: x_at_top, y: val_y_top });\r\n\r\n                const val_y_bottom = yScaleToUse.getValueForPixel(chartArea.bottom);\r\n                const x_at_bottom = (val_y_bottom - intercept) / slope; \r\n                points.push({ x: x_at_bottom, y: val_y_bottom });\r\n            } else { \r\n                 points.push({ x: xScale.getValueForPixel(chartArea.left), y: intercept});\r\n                 points.push({ x: xScale.getValueForPixel(chartArea.right), y: intercept});\r\n            }\r\n\r\n            const val_x_left = xScale.getValueForPixel(chartArea.left);\r\n            const y_at_left = fitter.f(val_x_left); \r\n            points.push({ x: val_x_left, y: y_at_left });\r\n\r\n            const val_x_right = xScale.getValueForPixel(chartArea.right);\r\n            const y_at_right = fitter.f(val_x_right); \r\n            points.push({ x: val_x_right, y: y_at_right });\r\n        }\r\n        \r\n        const chartMinX = xScale.getValueForPixel(chartArea.left); \r\n        const chartMaxX = xScale.getValueForPixel(chartArea.right); \r\n        \r\n        const yValsFromPixels = [yScaleToUse.getValueForPixel(chartArea.top), yScaleToUse.getValueForPixel(chartArea.bottom)];\r\n        const finiteYVals = yValsFromPixels.filter(y => isFinite(y));\r\n        // Ensure actualChartMinY and actualChartMaxY are correctly ordered for the filter\r\n        const actualChartMinY = finiteYVals.length > 0 ? Math.min(...finiteYVals) : -Infinity; \r\n        const actualChartMaxY = finiteYVals.length > 0 ? Math.max(...finiteYVals) : Infinity;\r\n        \r\n        let validPoints = points.filter(p => \r\n            isFinite(p.x) && isFinite(p.y) && \r\n            p.x >= chartMinX && p.x <= chartMaxX && p.y >= actualChartMinY && p.y <= actualChartMaxY\r\n        );\r\n        \r\n        validPoints = validPoints.filter((point, index, self) =>\r\n            index === self.findIndex((t) => (\r\n                Math.abs(t.x - point.x) < 1e-4 && Math.abs(t.y - point.y) < 1e-4 \r\n            ))\r\n        );\r\n        \r\n        if (validPoints.length >= 2) {\r\n            validPoints.sort((a,b) => a.x - b.x || a.y - b.y); \r\n\r\n            x1_px = xScale.getPixelForValue(validPoints[0].x);\r\n            y1_px = yScaleToUse.getPixelForValue(validPoints[0].y);\r\n            x2_px = xScale.getPixelForValue(validPoints[validPoints.length - 1].x);\r\n            y2_px = yScaleToUse.getPixelForValue(validPoints[validPoints.length - 1].y);\r\n        } else {\r\n            x1_px = NaN; y1_px = NaN; x2_px = NaN; y2_px = NaN;\r\n        }\r\n\r\n    } else {\r\n        const y_at_minx = fitter.f(fitter.minx); \r\n        const y_at_maxx = fitter.f(fitter.maxx); \r\n\r\n        x1_px = xScale.getPixelForValue(fitter.minx);\r\n        y1_px = yScaleToUse.getPixelForValue(y_at_minx);\r\n        x2_px = xScale.getPixelForValue(fitter.maxx);\r\n        y2_px = yScaleToUse.getPixelForValue(y_at_maxx);\r\n    }\r\n\r\n    // --- Line Clipping and Drawing ---\r\n    let clippedCoords = null;\r\n    if (isFinite(x1_px) && isFinite(y1_px) && isFinite(x2_px) && isFinite(y2_px)) {\r\n        clippedCoords = liangBarskyClip(x1_px, y1_px, x2_px, y2_px, chartArea);\r\n    } else {\r\n    }\r\n\r\n    if (clippedCoords) {\r\n        x1_px = clippedCoords.x1;\r\n        y1_px = clippedCoords.y1;\r\n        x2_px = clippedCoords.x2;\r\n        y2_px = clippedCoords.y2;\r\n\r\n        if (Math.abs(x1_px - x2_px) < 0.5 && Math.abs(y1_px - y2_px) < 0.5) { \r\n        } else {\r\n            ctx.lineWidth = lineWidth;\r\n            setLineStyle(ctx, lineStyle);\r\n            drawTrendline({ ctx, x1: x1_px, y1: y1_px, x2: x2_px, y2: y2_px, colorMin, colorMax });\r\n\r\n            if (fillColor) {\r\n                fillBelowTrendline(ctx, x1_px, y1_px, x2_px, y2_px, chartArea.bottom, fillColor);\r\n            }\r\n\r\n            const angle = Math.atan2(y2_px - y1_px, x2_px - x1_px);\r\n            \r\n            if (trendlineConfig.label && display !== false) {\r\n                let trendText = text;\r\n                if (displayValue) {\r\n                    if (isExponential) {\r\n                        const coefficient = fitter.coefficient();\r\n                        const growthRate = fitter.growthRate();\r\n                        trendText = `${text} (a=${coefficient.toFixed(2)}, b=${growthRate.toFixed(2)})`;\r\n                    } else {\r\n                        const displaySlope = fitter.slope();\r\n                        trendText = `${text} (Slope: ${\r\n                            percentage\r\n                                ? (displaySlope * 100).toFixed(2) + '%' \r\n                                : displaySlope.toFixed(2)\r\n                        })`;\r\n                    }\r\n                }\r\n                addTrendlineLabel(\r\n                    ctx,\r\n                    trendText,\r\n                    x1_px, \r\n                    y1_px,\r\n                    x2_px,\r\n                    y2_px,\r\n                    angle,\r\n                    color,\r\n                    family,\r\n                    size,\r\n                    offset\r\n                );\r\n            }\r\n        }\r\n    } else {\r\n    }\r\n};\r\n\r\n/**\r\n * Clips a line segment to a rectangular clipping window using the Liang-Barsky algorithm.\r\n * This algorithm is efficient for 2D line clipping against an axis-aligned rectangle.\r\n * It determines the portion of the line segment (x1,y1)-(x2,y2) that is visible within\r\n * the rectangle defined by chartArea {left, right, top, bottom}.\r\n * @param {number} x1 - Pixel coordinate for the start of the line (x-axis).\r\n * @param {number} y1 - Pixel coordinate for the start of the line (y-axis).\r\n * @param {number} x2 - Pixel coordinate for the end of the line (x-axis).\r\n * @param {number} y2 - Pixel coordinate for the end of the line (y-axis).\r\n * @param {Object} chartArea - The chart area with { left, right, top, bottom } pixel boundaries.\r\n * @returns {Object|null} An object with { x1, y1, x2, y2 } of the clipped line, \r\n *                        or null if the line is entirely outside the window or clipped to effectively a point.\r\n */\r\nfunction liangBarskyClip(x1, y1, x2, y2, chartArea) {\r\n    let dx = x2 - x1; // Change in x\r\n    let dy = y2 - y1; // Change in y\r\n    let t0 = 0.0;     // Parameter for the start of the clipped line segment (initially at x1, y1).\r\n                      // Represents the proportion along the line from (x1,y1) to (x2,y2).\r\n    let t1 = 1.0;     // Parameter for the end of the clipped line segment (initially at x2, y2).\r\n\r\n    // p and q arrays are used in the Liang-Barsky algorithm conditions.\r\n    // For each of the 4 clip edges (left, right, top, bottom):\r\n    // p[k] * t >= q[k]\r\n    // p values: -dx (left), dx (right), -dy (top), dy (bottom)\r\n    // q values: x1 - x_min (left), x_max - x1 (right), y1 - y_min (top), y_max - y1 (bottom)\r\n    // Note: Canvas y-coordinates increase downwards, so chartArea.top < chartArea.bottom.\r\n    const p = [-dx, dx, -dy, dy];\r\n    const q = [\r\n        x1 - chartArea.left,    // q[0] for left edge check\r\n        chartArea.right - x1,   // q[1] for right edge check\r\n        y1 - chartArea.top,     // q[2] for top edge check\r\n        chartArea.bottom - y1,  // q[3] for bottom edge check\r\n    ];\r\n\r\n    for (let i = 0; i < 4; i++) { // Iterate through the 4 clip edges (left, right, top, bottom).\r\n        if (p[i] === 0) { // Line is parallel to the i-th clipping edge.\r\n            if (q[i] < 0) { // Line is outside this parallel edge (e.g., for left edge, x1 < chartArea.left).\r\n                return null; // Line is completely outside, so reject.\r\n            }\r\n            // If q[i] >= 0, line is inside or on the parallel edge, so this edge doesn't clip it. Continue.\r\n        } else {\r\n            const r = q[i] / p[i]; // Parameter t where the line intersects this edge's infinite line.\r\n            if (p[i] < 0) { \r\n                // Line is potentially entering the clip region with respect to this edge.\r\n                // (e.g., for left edge, -dx < 0 means line goes from left to right, dx > 0).\r\n                // We want the largest t0 among all entry points.\r\n                if (r > t1) return null; // Line enters after it has already exited from another edge.\r\n                t0 = Math.max(t0, r);    // Update t0 to the latest entry point along the line.\r\n            } else { // p[i] > 0\r\n                // Line is potentially exiting the clip region with respect to this edge.\r\n                // (e.g., for left edge, -dx > 0 means line goes from right to left, dx < 0).\r\n                // We want the smallest t1 among all exit points.\r\n                if (r < t0) return null; // Line exits before it has entered from another edge.\r\n                t1 = Math.min(t1, r);    // Update t1 to the earliest exit point along the line.\r\n            }\r\n        }\r\n    }\r\n\r\n    // After checking all 4 edges:\r\n    // If t0 > t1, the line segment is completely outside the clipping window or is degenerate.\r\n    if (t0 > t1) return null; \r\n\r\n    // Calculate the new clipped coordinates using parameters t0 and t1.\r\n    // (x1_clipped, y1_clipped) = (x1, y1) + t0 * (dx, dy)\r\n    // (x2_clipped, y2_clipped) = (x1, y1) + t1 * (dx, dy)\r\n    const clippedX1 = x1 + t0 * dx;\r\n    const clippedY1 = y1 + t0 * dy;\r\n    const clippedX2 = x1 + t1 * dx;\r\n    const clippedY2 = y1 + t1 * dy;\r\n\r\n    return { x1: clippedX1, y1: clippedY1, x2: clippedX2, y2: clippedY2 };\r\n}\r\n// Removed adjustLineForOverflow function","/**\r\n * Adds a label to the trendline at the calculated angle.\r\n * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.\r\n * @param {string} label - The label text to add.\r\n * @param {number} x1 - The starting x-coordinate of the trendline.\r\n * @param {number} y1 - The starting y-coordinate of the trendline.\r\n * @param {number} x2 - The ending x-coordinate of the trendline.\r\n * @param {number} y2 - The ending y-coordinate of the trendline.\r\n * @param {number} angle - The angle (in radians) of the trendline.\r\n * @param {string} labelColor - The color of the label text.\r\n * @param {string} family - The font family for the label text.\r\n * @param {number} size - The font size for the label text.\r\n * @param {number} offset - The offset of the label from the trendline\r\n */\r\nexport const addTrendlineLabel = (\r\n    ctx,\r\n    label,\r\n    x1,\r\n    y1,\r\n    x2,\r\n    y2,\r\n    angle,\r\n    labelColor,\r\n    family,\r\n    size,\r\n    offset\r\n) => {\r\n    // Set the label font and color\r\n    ctx.font = `${size}px ${family}`;\r\n    ctx.fillStyle = labelColor;\r\n\r\n    // Label width\r\n    const labelWidth = ctx.measureText(label).width;\r\n\r\n    // Calculate the center of the trendline\r\n    const labelX = (x1 + x2) / 2;\r\n    const labelY = (y1 + y2) / 2;\r\n\r\n    // Save the current state of the canvas\r\n    ctx.save();\r\n\r\n    // Translate to the label position\r\n    ctx.translate(labelX, labelY);\r\n\r\n    // Rotate the context to align with the trendline\r\n    ctx.rotate(angle);\r\n\r\n    // Adjust for the length of the label and rotation\r\n    const adjustedX = -labelWidth / 2; // Center the label horizontally\r\n    const adjustedY = offset; // Adjust Y to compensate for the height\r\n\r\n    // Draw the label\r\n    ctx.fillText(label, adjustedX, adjustedY);\r\n\r\n    // Restore the canvas state\r\n    ctx.restore();\r\n}; ","import { addFitter } from '../components/trendline.js';\r\nimport { getScales } from '../utils/drawing.js';\r\n\r\nexport const pluginTrendlineLinear = {\r\n    id: 'chartjs-plugin-trendline',\r\n\r\n    afterDatasetsDraw: (chartInstance) => {\r\n        const ctx = chartInstance.ctx;\r\n        const { xScale, yScale } = getScales(chartInstance);\r\n\r\n        const sortedDatasets = chartInstance.data.datasets\r\n            .map((dataset, index) => ({ dataset, index }))\r\n            .filter((entry) => entry.dataset.trendlineLinear || entry.dataset.trendlineExponential)\r\n            .sort((a, b) => {\r\n                const orderA = a.dataset.order ?? 0;\r\n                const orderB = b.dataset.order ?? 0;\r\n\r\n                // Push 0-order datasets to the end (they draw last / on top)\r\n                if (orderA === 0 && orderB !== 0) return 1;\r\n                if (orderB === 0 && orderA !== 0) return -1;\r\n\r\n                // Otherwise, draw lower order first\r\n                return orderA - orderB;\r\n            });\r\n\r\n        sortedDatasets.forEach(({ dataset, index }) => {\r\n            const showTrendline =\r\n                dataset.alwaysShowTrendline ||\r\n                chartInstance.isDatasetVisible(index);\r\n\r\n            if (showTrendline && dataset.data.length > 1) {\r\n                const datasetMeta = chartInstance.getDatasetMeta(index);\r\n                addFitter(datasetMeta, ctx, dataset, xScale, yScale);\r\n            }\r\n        });\r\n\r\n        // Reset to solid line after drawing trendline\r\n        ctx.setLineDash([]);\r\n    },\r\n\r\n    beforeInit: (chartInstance) => {\r\n        const datasets = chartInstance.data.datasets;\r\n\r\n        datasets.forEach((dataset) => {\r\n            const trendlineConfig = dataset.trendlineLinear || dataset.trendlineExponential;\r\n            if (trendlineConfig && trendlineConfig.label) {\r\n                const label = trendlineConfig.label;\r\n\r\n                // Access chartInstance to update legend labels\r\n                const originalGenerateLabels =\r\n                    chartInstance.legend.options.labels.generateLabels;\r\n\r\n                chartInstance.legend.options.labels.generateLabels = function (\r\n                    chart\r\n                ) {\r\n                    const defaultLabels = originalGenerateLabels(chart);\r\n\r\n                    const legendConfig = trendlineConfig.legend;\r\n\r\n                    // Display the legend is it's populated and not set to hidden\r\n                    if (legendConfig && legendConfig.display !== false) {\r\n                        defaultLabels.push({\r\n                            text: legendConfig.text || label + ' (Trendline)',\r\n                            strokeStyle:\r\n                                legendConfig.color ||\r\n                                dataset.borderColor ||\r\n                                'rgba(169,169,169, .6)',\r\n                            fillStyle: legendConfig.fillStyle || 'transparent',\r\n                            lineCap: legendConfig.lineCap || 'butt',\r\n                            lineDash: legendConfig.lineDash || [],\r\n                            lineWidth: legendConfig.width || 1,\r\n                        });\r\n                    }\r\n                    return defaultLabels;\r\n                };\r\n            }\r\n        });\r\n    },\r\n};\r\n","import { pluginTrendlineLinear } from './core/plugin.js';\r\n\r\n// If we're in the browser and have access to the global Chart obj, register plugin automatically\r\nif (typeof window !== 'undefined' && window.Chart) {\r\n    if (window.Chart.hasOwnProperty('register')) {\r\n        window.Chart.register(pluginTrendlineLinear);\r\n    } else {\r\n        window.Chart.plugins.register(pluginTrendlineLinear);\r\n    }\r\n}\r\n\r\n// Export the plugin\r\nexport default pluginTrendlineLinear; "],"names":["LineFitter","constructor","this","count","sumx","sumy","sumx2","sumxy","minx","Number","MAX_VALUE","maxx","MIN_VALUE","_cachedSlope","_cachedIntercept","_cacheValid","add","x","y","slope","_computeCoefficients","intercept","f","fo","scale","denominator","ExponentialFitter","sumlny","sumxlny","hasValidData","dataPoints","_cachedGrowthRate","_cachedCoefficient","_cachedCorrelation","lny","Math","log","isFinite","push","growthRate","coefficient","abs","result","exp","correlation","lnA","meanLnY","ssTotal","ssRes","point","predictedLnY","pow","max","addFitter","datasetMeta","ctx","dataset","xScale","yScale","yAxisID","yScaleToUse","controller","chart","scales","isExponential","trendlineExponential","trendlineConfig","trendlineLinear","defaultColor","borderColor","colorMin","colorMax","width","lineWidth","borderWidth","lineStyle","fillColor","trendoffset","color","text","display","displayValue","offset","percentage","label","family","size","font","chartOptions","options","parsingOptions","parsing","undefined","xAxisKey","yAxisKey","fitter","data","length","effectiveFirstIndex","firstNonNullAfterOffset","slice","findIndex","d","firstNonNull","x1_px","y1_px","x2_px","y2_px","xy","forEach","index","includes","type","t","yValue","isNaN","Date","getTime","xVal","yVal","xIsValid","yIsValid","chartLabels","labels","timeValue","chartArea","projection","points","val_x_left","getValueForPixel","left","y_at_left","val_x_right","right","y_at_right","val_y_top","top","x_at_top","val_y_bottom","bottom","x_at_bottom","chartMinX","chartMaxX","finiteYVals","filter","actualChartMinY","min","Infinity","actualChartMaxY","validPoints","p","self","sort","a","b","getPixelForValue","NaN","y_at_minx","y_at_maxx","clippedCoords","x1","y1","x2","y2","dx","dy","t0","t1","q","i","r","liangBarskyClip","setLineDash","setLineStyle","beginPath","moveTo","lineTo","gradientLength","sqrt","console","warn","strokeStyle","gradient","createLinearGradient","addColorStop","e","stroke","closePath","drawTrendline","drawBottom","fillStyle","fill","fillBelowTrendline","angle","atan2","trendText","toFixed","displaySlope","labelColor","labelWidth","measureText","labelX","labelY","save","translate","rotate","adjustedX","adjustedY","fillText","restore","addTrendlineLabel","pluginTrendlineLinear","id","afterDatasetsDraw","chartInstance","Object","values","isHorizontal","getScales","datasets","map","entry","orderA","order","orderB","alwaysShowTrendline","isDatasetVisible","getDatasetMeta","beforeInit","originalGenerateLabels","legend","generateLabels","defaultLabels","legendConfig","lineCap","lineDash","window","Chart","hasOwnProperty","register","plugins"],"mappings":";;;;;;gPAGO,MAAMA,EACT,WAAAC,GACIC,KAAKC,MAAQ,EACbD,KAAKE,KAAO,EACZF,KAAKG,KAAO,EACZH,KAAKI,MAAQ,EACbJ,KAAKK,MAAQ,EACbL,KAAKM,KAAOC,OAAOC,UACnBR,KAAKS,KAAOF,OAAOG,UACnBV,KAAKW,aAAe,KACpBX,KAAKY,iBAAmB,KACxBZ,KAAKa,aAAc,CACvB,CAOA,GAAAC,CAAIC,EAAGC,GACHhB,KAAKE,MAAQa,EACbf,KAAKG,MAAQa,EACbhB,KAAKI,OAASW,EAAIA,EAClBf,KAAKK,OAASU,EAAIC,EACdD,EAAIf,KAAKM,OAAMN,KAAKM,KAAOS,GAC3BA,EAAIf,KAAKS,OAAMT,KAAKS,KAAOM,GAC/Bf,KAAKC,QACLD,KAAKa,aAAc,CACvB,CAMA,KAAAI,GAII,OAHKjB,KAAKa,aACNb,KAAKkB,uBAEFlB,KAAKW,YAChB,CAMA,SAAAQ,GAII,OAHKnB,KAAKa,aACNb,KAAKkB,uBAEFlB,KAAKY,gBAChB,CAOA,CAAAQ,CAAEL,GACE,OAAOf,KAAKiB,QAAUF,EAAIf,KAAKmB,WACnC,CAMA,EAAAE,GACI,OAAQrB,KAAKmB,YAAcnB,KAAKiB,OACpC,CAMA,KAAAK,GACI,OAAOtB,KAAKiB,OAChB,CAEA,oBAAAC,GACI,MAAMK,EAAcvB,KAAKC,MAAQD,KAAKI,MAAQJ,KAAKE,KAAOF,KAAKE,KAC/DF,KAAKW,cAAgBX,KAAKC,MAAQD,KAAKK,MAAQL,KAAKE,KAAOF,KAAKG,MAAQoB,EACxEvB,KAAKY,kBAAoBZ,KAAKG,KAAOH,KAAKW,aAAeX,KAAKE,MAAQF,KAAKC,MAC3ED,KAAKa,aAAc,CACvB,ECjFG,MAAMW,EACT,WAAAzB,GACIC,KAAKC,MAAQ,EACbD,KAAKE,KAAO,EACZF,KAAKyB,OAAS,EACdzB,KAAKI,MAAQ,EACbJ,KAAK0B,QAAU,EACf1B,KAAKM,KAAOC,OAAOC,UACnBR,KAAKS,KAAOF,OAAOG,UACnBV,KAAK2B,cAAe,EACpB3B,KAAK4B,WAAa,GAClB5B,KAAK6B,kBAAoB,KACzB7B,KAAK8B,mBAAqB,KAC1B9B,KAAK+B,mBAAqB,KAC1B/B,KAAKa,aAAc,CACvB,CAOA,GAAAC,CAAIC,EAAGC,GACH,GAAIA,GAAK,EAEL,YADAhB,KAAK2B,cAAe,GAIxB,MAAMK,EAAMC,KAAKC,IAAIlB,GAChBmB,SAASH,IAKdhC,KAAKE,MAAQa,EACbf,KAAKyB,QAAUO,EACfhC,KAAKI,OAASW,EAAIA,EAClBf,KAAK0B,SAAWX,EAAIiB,EAChBjB,EAAIf,KAAKM,OAAMN,KAAKM,KAAOS,GAC3BA,EAAIf,KAAKS,OAAMT,KAAKS,KAAOM,GAC/Bf,KAAK4B,WAAWQ,KAAK,CAACrB,IAAGC,IAAGgB,QAC5BhC,KAAKC,QACLD,KAAKa,aAAc,GAZfb,KAAK2B,cAAe,CAa5B,CAMA,UAAAU,GACI,OAAKrC,KAAK2B,cAAgB3B,KAAKC,MAAQ,EAAU,GAC5CD,KAAKa,aACNb,KAAKkB,uBAEFlB,KAAK6B,kBAChB,CAMA,WAAAS,GACI,OAAKtC,KAAK2B,cAAgB3B,KAAKC,MAAQ,EAAU,GAC5CD,KAAKa,aACNb,KAAKkB,uBAEFlB,KAAK8B,mBAChB,CAOA,CAAAV,CAAEL,GACE,IAAKf,KAAK2B,cAAgB3B,KAAKC,MAAQ,EAAG,OAAO,EAMjD,GALKD,KAAKa,aACNb,KAAKkB,uBAILe,KAAKM,IAAIvC,KAAK6B,kBAAoBd,GAAK,IAAK,OAAO,EAEvD,MAAMyB,EAASxC,KAAK8B,mBAAqBG,KAAKQ,IAAIzC,KAAK6B,kBAAoBd,GAC3E,OAAOoB,SAASK,GAAUA,EAAS,CACvC,CAMA,WAAAE,GACI,OAAK1C,KAAK2B,cAAgB3B,KAAKC,MAAQ,EAAU,GAC5CD,KAAKa,aACNb,KAAKkB,uBAEFlB,KAAK+B,mBAChB,CAMA,KAAAT,GACI,OAAOtB,KAAKqC,YAChB,CAEA,oBAAAnB,GACI,IAAKlB,KAAK2B,cAAgB3B,KAAKC,MAAQ,EAKnC,OAJAD,KAAK6B,kBAAoB,EACzB7B,KAAK8B,mBAAqB,EAC1B9B,KAAK+B,mBAAqB,OAC1B/B,KAAKa,aAAc,GAIvB,MAAMU,EAAcvB,KAAKC,MAAQD,KAAKI,MAAQJ,KAAKE,KAAOF,KAAKE,KAC/D,GAAI+B,KAAKM,IAAIhB,GAAe,MAKxB,OAJAvB,KAAK6B,kBAAoB,EACzB7B,KAAK8B,mBAAqB,EAC1B9B,KAAK+B,mBAAqB,OAC1B/B,KAAKa,aAAc,GAIvBb,KAAK6B,mBAAqB7B,KAAKC,MAAQD,KAAK0B,QAAU1B,KAAKE,KAAOF,KAAKyB,QAAUF,EACjF,MAAMoB,GAAO3C,KAAKyB,OAASzB,KAAK6B,kBAAoB7B,KAAKE,MAAQF,KAAKC,MACtED,KAAK8B,mBAAqBG,KAAKQ,IAAIE,GAEnC,MAAMC,EAAU5C,KAAKyB,OAASzB,KAAKC,MACnC,IAAI4C,EAAU,EACVC,EAAQ,EAEZ,IAAK,MAAMC,KAAS/C,KAAK4B,WAAY,CACjC,MAAMoB,EAAeL,EAAM3C,KAAK6B,kBAAoBkB,EAAMhC,EAC1D8B,GAAWZ,KAAKgB,IAAIF,EAAMf,IAAMY,EAAS,GACzCE,GAASb,KAAKgB,IAAIF,EAAMf,IAAMgB,EAAc,EAChD,CAEAhD,KAAK+B,mBAAiC,IAAZc,EAAgB,EAAIZ,KAAKiB,IAAI,EAAG,EAAKJ,EAAQD,GACvE7C,KAAKa,aAAc,CACvB,EC5IG,MCQMsC,EAAY,CAACC,EAAaC,EAAKC,EAASC,EAAQC,KACzD,MAAMC,EAAUH,EAAQG,SAAW,IAC7BC,EAAcN,EAAYO,WAAWC,MAAMC,OAAOJ,IAAYD,EAG9DM,IAAkBR,EAAQS,qBAC1BC,EAAkBV,EAAQS,sBAAwBT,EAAQW,iBAAmB,CAAA,EAE7EC,EAAeZ,EAAQa,aAAe,yBACtCC,SACFA,EAAWF,EAAYG,SACvBA,EAAWH,EACXI,MAAOC,EAAYjB,EAAQkB,aAAe,EAACC,UAC3CA,EAAY,QAAOC,UACnBA,GAAY,GAEZV,EACJ,IAAIW,EAAcX,EAAgBW,aAAe,EAEjD,MAAMC,MACFA,EAAQV,EAAYW,KACpBA,GAAOf,EAAgB,wBAA0B,aAAWgB,QAC5DA,GAAU,EAAIC,aACdA,GAAe,EAAIC,OACnBA,EAAS,GAAEC,WACXA,GAAa,GACZjB,GAAmBA,EAAgBkB,OAAU,CAAA,GAE5CC,OACFA,EAAS,qDAAoDC,KAC7DA,EAAO,IACNpB,GAAmBA,EAAgBkB,OAASlB,EAAgBkB,MAAMG,MAAS,GAE1EC,EAAelC,EAAYO,WAAWC,MAAM2B,QAC5CC,EAC8B,iBAAzBF,EAAaG,QACdH,EAAaG,aACbC,EACJC,EACF3B,GAAiB2B,UAAYH,GAAgBG,UAAY,IACvDC,EACF5B,GAAiB4B,UAAYJ,GAAgBI,UAAY,IAE7D,IAAIC,EAAS/B,EAAgB,IAAItC,EAAsB,IAAI1B,EAMvDmC,KAAKM,IAAIoC,IAAgBrB,EAAQwC,KAAKC,SAAQpB,EAAc,GAKhE,IAAIqB,EAAsB,EAC1B,GAAIrB,EAAc,EAAG,CAEjB,MAAMsB,EAA0B3C,EAAQwC,KAAKI,MAAMvB,GAAawB,UAAWC,GAAMA,SAE7EJ,GAD4B,IAA5BC,EACsBtB,EAAcsB,EAGd3C,EAAQwC,KAAKC,MAE3C,KAAO,CAGH,MAAMM,EAAe/C,EAAQwC,KAAKK,UAAWC,GAAMA,SAE/CJ,GADiB,IAAjBK,EACsBA,EAGA/C,EAAQwC,KAAKC,MAE3C,CAIA,IAmEIO,EAAOC,EAAOC,EAAOC,EAnErBC,EAAKV,EAAsB1C,EAAQwC,KAAKC,QAAuD,iBAAtCzC,EAAQwC,KAAKE,GA8D1E,GA3DA1C,EAAQwC,KAAKa,QAAQ,CAACb,EAAMc,KAExB,GAAY,MAARd,KAKAnB,EAAc,GAAKiC,EAAQZ,GAI3BrB,EAAc,GAAKiC,GAAStD,EAAQwC,KAAKC,OAASpB,GAGtD,GAAI,CAAC,OAAQ,cAAckC,SAAStD,EAAOgC,QAAQuB,OAASJ,EAAI,CAE5D,IAAI3F,EAAsB,MAAlB+E,EAAKH,GAAoBG,EAAKH,GAAYG,EAAKiB,EACvD,MAAMC,EAASlB,EAAKF,GAGX,MAAL7E,QAAmB2E,IAAN3E,GAA6B,MAAViG,GAAmBC,MAAMD,IACzDnB,EAAO/E,IAAI,IAAIoG,KAAKnG,GAAGoG,UAAWH,EAG1C,MAAO,GAAIN,EAAI,CACX,MAAMU,EAAOtB,EAAKH,GACZ0B,EAAOvB,EAAKF,GAEZ0B,EAAmB,MAARF,IAAiBH,MAAMG,GAClCG,EAAmB,MAARF,IAAiBJ,MAAMI,GAGpCC,GAAYC,GACZ1B,EAAO/E,IAAIsG,EAAMC,EAGzB,MAAO,GAAI,CAAC,OAAQ,cAAcR,SAAStD,EAAOgC,QAAQuB,QAAUJ,EAAI,CAEpE,MAAMc,EAAcpE,EAAYO,WAAWC,MAAMkC,KAAK2B,OACtD,GAAID,GAAeA,EAAYZ,IAAkB,MAARd,IAAiBmB,MAAMnB,GAAO,CACnE,MAAM4B,EAAY,IAAIR,KAAKM,EAAYZ,IAAQO,UAC1CF,MAAMS,IACP7B,EAAO/E,IAAI4G,EAAW5B,EAE9B,CACJ,MAMgB,MAARA,GAAiBmB,MAAMnB,IACtBD,EAAO/E,IAAI8F,EAAOd,KAO3BD,EAAO5F,MAAQ,EACf,OAMJ,MAAM0H,EAAYvE,EAAYO,WAAWC,MAAM+D,UAG/C,GAAI3D,EAAgB4D,WAAY,CAC5B,IAAIC,EAAS,GAEb,GAAI/D,EAAe,CAEf,MAAMgE,EAAavE,EAAOwE,iBAAiBJ,EAAUK,MAC/CC,EAAYpC,EAAOzE,EAAE0G,GAC3BD,EAAOzF,KAAK,CAAErB,EAAG+G,EAAY9G,EAAGiH,IAEhC,MAAMC,EAAc3E,EAAOwE,iBAAiBJ,EAAUQ,OAChDC,EAAavC,EAAOzE,EAAE8G,GAC5BL,EAAOzF,KAAK,CAAErB,EAAGmH,EAAalH,EAAGoH,GACrC,KAAO,CAEH,MAAMnH,EAAQ4E,EAAO5E,QACfE,EAAY0E,EAAO1E,YAEzB,GAAIc,KAAKM,IAAItB,GAAS,KAAM,CACxB,MAAMoH,EAAY3E,EAAYqE,iBAAiBJ,EAAUW,KACnDC,GAAYF,EAAYlH,GAAaF,EAC3C4G,EAAOzF,KAAK,CAAErB,EAAGwH,EAAUvH,EAAGqH,IAE9B,MAAMG,EAAe9E,EAAYqE,iBAAiBJ,EAAUc,QACtDC,GAAeF,EAAerH,GAAaF,EACjD4G,EAAOzF,KAAK,CAAErB,EAAG2H,EAAa1H,EAAGwH,GACrC,MACKX,EAAOzF,KAAK,CAAErB,EAAGwC,EAAOwE,iBAAiBJ,EAAUK,MAAOhH,EAAGG,IAC7D0G,EAAOzF,KAAK,CAAErB,EAAGwC,EAAOwE,iBAAiBJ,EAAUQ,OAAQnH,EAAGG,IAGnE,MAAM2G,EAAavE,EAAOwE,iBAAiBJ,EAAUK,MAC/CC,EAAYpC,EAAOzE,EAAE0G,GAC3BD,EAAOzF,KAAK,CAAErB,EAAG+G,EAAY9G,EAAGiH,IAEhC,MAAMC,EAAc3E,EAAOwE,iBAAiBJ,EAAUQ,OAChDC,EAAavC,EAAOzE,EAAE8G,GAC5BL,EAAOzF,KAAK,CAAErB,EAAGmH,EAAalH,EAAGoH,GACrC,CAEA,MAAMO,EAAYpF,EAAOwE,iBAAiBJ,EAAUK,MAC9CY,EAAYrF,EAAOwE,iBAAiBJ,EAAUQ,OAG9CU,EADkB,CAACnF,EAAYqE,iBAAiBJ,EAAUW,KAAM5E,EAAYqE,iBAAiBJ,EAAUc,SACzEK,OAAO9H,GAAKmB,SAASnB,IAEnD+H,EAAkBF,EAAY9C,OAAS,EAAI9D,KAAK+G,OAAOH,IAAgBI,IACvEC,EAAkBL,EAAY9C,OAAS,EAAI9D,KAAKiB,OAAO2F,GAAeI,IAE5E,IAAIE,EAActB,EAAOiB,OAAOM,GAC5BjH,SAASiH,EAAErI,IAAMoB,SAASiH,EAAEpI,IAC5BoI,EAAErI,GAAK4H,GAAaS,EAAErI,GAAK6H,GAAaQ,EAAEpI,GAAK+H,GAAmBK,EAAEpI,GAAKkI,GAG7EC,EAAcA,EAAYL,OAAO,CAAC/F,EAAO6D,EAAOyC,IAC5CzC,IAAUyC,EAAKlD,UAAWY,GACtB9E,KAAKM,IAAIwE,EAAEhG,EAAIgC,EAAMhC,GAAK,MAAQkB,KAAKM,IAAIwE,EAAE/F,EAAI+B,EAAM/B,GAAK,OAIhEmI,EAAYpD,QAAU,GACtBoD,EAAYG,KAAK,CAACC,EAAEC,IAAMD,EAAExI,EAAIyI,EAAEzI,GAAKwI,EAAEvI,EAAIwI,EAAExI,GAE/CsF,EAAQ/C,EAAOkG,iBAAiBN,EAAY,GAAGpI,GAC/CwF,EAAQ7C,EAAY+F,iBAAiBN,EAAY,GAAGnI,GACpDwF,EAAQjD,EAAOkG,iBAAiBN,EAAYA,EAAYpD,OAAS,GAAGhF,GACpE0F,EAAQ/C,EAAY+F,iBAAiBN,EAAYA,EAAYpD,OAAS,GAAG/E,KAEzEsF,EAAQoD,IAAKnD,EAAQmD,IAAKlD,EAAQkD,IAAKjD,EAAQiD,IAGvD,KAAO,CACH,MAAMC,EAAY9D,EAAOzE,EAAEyE,EAAOvF,MAC5BsJ,EAAY/D,EAAOzE,EAAEyE,EAAOpF,MAElC6F,EAAQ/C,EAAOkG,iBAAiB5D,EAAOvF,MACvCiG,EAAQ7C,EAAY+F,iBAAiBE,GACrCnD,EAAQjD,EAAOkG,iBAAiB5D,EAAOpF,MACvCgG,EAAQ/C,EAAY+F,iBAAiBG,EACzC,CAGA,IAAIC,EAAgB,KAMpB,GALI1H,SAASmE,IAAUnE,SAASoE,IAAUpE,SAASqE,IAAUrE,SAASsE,KAClEoD,EAsER,SAAyBC,EAAIC,EAAIC,EAAIC,EAAItC,GACrC,IAAIuC,EAAKF,EAAKF,EACVK,EAAKF,EAAKF,EACVK,EAAK,EAELC,EAAK,EAQT,MAAMjB,EAAI,EAAEc,EAAIA,GAAKC,EAAIA,GACnBG,EAAI,CACNR,EAAKnC,EAAUK,KACfL,EAAUQ,MAAQ2B,EAClBC,EAAKpC,EAAUW,IACfX,EAAUc,OAASsB,GAGvB,IAAK,IAAIQ,EAAI,EAAGA,EAAI,EAAGA,IACnB,GAAa,IAATnB,EAAEmB,IACF,GAAID,EAAEC,GAAK,EACP,OAAO,SAGR,CACH,MAAMC,EAAIF,EAAEC,GAAKnB,EAAEmB,GACnB,GAAInB,EAAEmB,GAAK,EAAG,CAIV,GAAIC,EAAIH,EAAI,OAAO,KACnBD,EAAKnI,KAAKiB,IAAIkH,EAAII,EACtB,KAAO,CAIH,GAAIA,EAAIJ,EAAI,OAAO,KACnBC,EAAKpI,KAAK+G,IAAIqB,EAAIG,EACtB,CACJ,CAKJ,GAAIJ,EAAKC,EAAI,OAAO,KAUpB,MAAO,CAAEP,GALSA,EAAKM,EAAKF,EAKJH,GAJNA,EAAKK,EAAKD,EAIWH,GAHrBF,EAAKO,EAAKH,EAG0BD,GAFpCF,EAAKM,EAAKF,EAGhC,CAhIwBM,CAAgBnE,EAAOC,EAAOC,EAAOC,EAAOkB,IAI5DkC,EAMA,GALAvD,EAAQuD,EAAcC,GACtBvD,EAAQsD,EAAcE,GACtBvD,EAAQqD,EAAcG,GACtBvD,EAAQoD,EAAcI,GAElBhI,KAAKM,IAAI+D,EAAQE,GAAS,IAAOvE,KAAKM,IAAIgE,EAAQE,GAAS,QACxD,CACHpD,EAAIkB,UAAYA,ED9OA,EAAClB,EAAKoB,KAC9B,OAAQA,GACJ,IAAK,SACDpB,EAAIqH,YAAY,CAAC,EAAG,IACpB,MACJ,IAAK,SACDrH,EAAIqH,YAAY,CAAC,EAAG,IACpB,MACJ,IAAK,UACDrH,EAAIqH,YAAY,CAAC,EAAG,EAAG,EAAG,IAC1B,MAEJ,QACIrH,EAAIqH,YAAY,MCkOhBC,CAAatH,EAAKoB,GDlND,GAAGpB,MAAKyG,KAAIC,KAAIC,KAAIC,KAAI7F,WAAUC,eAE3D,GAAKlC,SAAS2H,IAAQ3H,SAAS4H,IAAQ5H,SAAS6H,IAAQ7H,SAAS8H,GAAjE,CAQA5G,EAAIuH,YACJvH,EAAIwH,OAAOf,EAAIC,GACf1G,EAAIyH,OAAOd,EAAIC,GAEf,IAEI,MAAMC,EAAKF,EAAKF,EACVK,EAAKF,EAAKF,EACVgB,EAAiB9I,KAAK+I,KAAKd,EAAKA,EAAKC,EAAKA,GAGhD,GAAIY,EAAiB,IACjBE,QAAQC,KAAK,gDAAiD,CAAEpB,KAAIC,KAAIC,KAAIC,KAAIlE,OAAQgF,IACxF1H,EAAI8H,YAAc/G,MACf,CACH,IAAIgH,EAAW/H,EAAIgI,qBAAqBvB,EAAIC,EAAIC,EAAIC,GACpDmB,EAASE,aAAa,EAAGlH,GACzBgH,EAASE,aAAa,EAAGjH,GACzBhB,EAAI8H,YAAcC,CACtB,CACJ,CAAE,MAAOG,GAELN,QAAQC,KAAK,+CAAgDK,GAC7DlI,EAAI8H,YAAc/G,CACtB,CAEAf,EAAImI,SACJnI,EAAIoI,WA7BJ,MALIR,QAAQC,KACJ,+DACA,CAAEpB,KAAIC,KAAIC,KAAIC,QC8MdyB,CAAc,CAAErI,MAAKyG,GAAIxD,EAAOyD,GAAIxD,EAAOyD,GAAIxD,EAAOyD,GAAIxD,EAAOrC,WAAUC,aAEvEK,GDnKkB,EAACrB,EAAKyG,EAAIC,EAAIC,EAAIC,EAAI0B,EAAYjH,KAG3DvC,SAAS2H,IACT3H,SAAS4H,IACT5H,SAAS6H,IACT7H,SAAS8H,IACT9H,SAASwJ,IASdtI,EAAIuH,YACJvH,EAAIwH,OAAOf,EAAIC,GACf1G,EAAIyH,OAAOd,EAAIC,GACf5G,EAAIyH,OAAOd,EAAI2B,GACftI,EAAIyH,OAAOhB,EAAI6B,GACftI,EAAIyH,OAAOhB,EAAIC,GACf1G,EAAIoI,YAEJpI,EAAIuI,UAAYlH,EAChBrB,EAAIwI,QAhBAZ,QAAQC,KACJ,qEACA,CAAEpB,KAAIC,KAAIC,KAAIC,KAAI0B,gBCyJdG,CAAmBzI,EAAKiD,EAAOC,EAAOC,EAAOC,EAAOkB,EAAUc,OAAQ/D,GAG1E,MAAMqH,EAAQ9J,KAAK+J,MAAMvF,EAAQF,EAAOC,EAAQF,GAEhD,GAAItC,EAAgBkB,QAAqB,IAAZJ,EAAmB,CAC5C,IAAImH,EAAYpH,EAChB,GAAIE,EACA,GAAIjB,EAAe,CACf,MAAMxB,EAAcuD,EAAOvD,cACrBD,EAAawD,EAAOxD,aAC1B4J,EAAY,GAAGpH,QAAWvC,EAAY4J,QAAQ,SAAS7J,EAAW6J,QAAQ,KAC9E,KAAO,CACH,MAAMC,EAAetG,EAAO5E,QAC5BgL,EAAY,GAAGpH,aACXI,GACsB,IAAfkH,GAAoBD,QAAQ,GAAK,IAClCC,EAAaD,QAAQ,KAEnC,CC5Qa,EAC7B7I,EACA6B,EACA4E,EACAC,EACAC,EACAC,EACA8B,EACAK,EACAjH,EACAC,EACAJ,KAGA3B,EAAIgC,KAAO,GAAGD,OAAUD,IACxB9B,EAAIuI,UAAYQ,EAGhB,MAAMC,EAAahJ,EAAIiJ,YAAYpH,GAAOZ,MAGpCiI,GAAUzC,EAAKE,GAAM,EACrBwC,GAAUzC,EAAKE,GAAM,EAG3B5G,EAAIoJ,OAGJpJ,EAAIqJ,UAAUH,EAAQC,GAGtBnJ,EAAIsJ,OAAOZ,GAGX,MAAMa,GAAaP,EAAa,EAC1BQ,EAAY7H,EAGlB3B,EAAIyJ,SAAS5H,EAAO0H,EAAWC,GAG/BxJ,EAAI0J,WDqOQC,CACI3J,EACA4I,EACA3F,EACAC,EACAC,EACAC,EACAsF,EACAnH,EACAO,EACAC,EACAJ,EAER,CACJ,GEvSI,MAACiI,EAAwB,CACjCC,GAAI,2BAEJC,kBAAoBC,IAChB,MAAM/J,EAAM+J,EAAc/J,KACpBE,OAAEA,EAAMC,OAAEA,GHHC,CAAC4J,IACtB,IAAI7J,EAAQC,EACZ,IAAK,MAAMlC,KAAS+L,OAAOC,OAAOF,EAAcvJ,QAG5C,GAFIvC,EAAMiM,eAAgBhK,EAASjC,EAC9BkC,EAASlC,EACViC,GAAUC,EAAQ,MAE1B,MAAO,CAAED,SAAQC,WGJcgK,CAAUJ,GAEdA,EAActH,KAAK2H,SACrCC,IAAI,CAACpK,EAASsD,KAAK,CAAQtD,UAASsD,WACpCkC,OAAQ6E,GAAUA,EAAMrK,QAAQW,iBAAmB0J,EAAMrK,QAAQS,sBACjEuF,KAAK,CAACC,EAAGC,KACN,MAAMoE,EAASrE,EAAEjG,QAAQuK,OAAS,EAC5BC,EAAStE,EAAElG,QAAQuK,OAAS,EAGlC,OAAe,IAAXD,GAA2B,IAAXE,EAAqB,EAC1B,IAAXA,GAA2B,IAAXF,GAAqB,EAGlCA,EAASE,IAGTnH,QAAQ,EAAGrD,UAASsD,YAK/B,IAHItD,EAAQyK,qBACRX,EAAcY,iBAAiBpH,KAEdtD,EAAQwC,KAAKC,OAAS,EAAG,CAC1C,MAAM3C,EAAcgK,EAAca,eAAerH,GACjDzD,EAAUC,EAAaC,EAAKC,EAASC,EAAQC,EACjD,IAIJH,EAAIqH,YAAY,KAGpBwD,WAAad,IACQA,EAActH,KAAK2H,SAE3B9G,QAASrD,IACd,MAAMU,EAAkBV,EAAQW,iBAAmBX,EAAQS,qBAC3D,GAAIC,GAAmBA,EAAgBkB,MAAO,CAC1C,MAAMA,EAAQlB,EAAgBkB,MAGxBiJ,EACFf,EAAcgB,OAAO7I,QAAQkC,OAAO4G,eAExCjB,EAAcgB,OAAO7I,QAAQkC,OAAO4G,eAAiB,SACjDzK,GAEA,MAAM0K,EAAgBH,EAAuBvK,GAEvC2K,EAAevK,EAAgBoK,OAgBrC,OAbIG,IAAyC,IAAzBA,EAAazJ,SAC7BwJ,EAAclM,KAAK,CACfyC,KAAM0J,EAAa1J,MAAQK,EAAQ,eACnCiG,YACIoD,EAAa3J,OACbtB,EAAQa,aACR,wBACJyH,UAAW2C,EAAa3C,WAAa,cACrC4C,QAASD,EAAaC,SAAW,OACjCC,SAAUF,EAAaE,UAAY,GACnClK,UAAWgK,EAAajK,OAAS,IAGlCgK,CACX,CACJ,YCxEU,oBAAXI,QAA0BA,OAAOC,QACpCD,OAAOC,MAAMC,eAAe,YAC5BF,OAAOC,MAAME,SAAS5B,GAEtByB,OAAOC,MAAMG,QAAQD,SAAS5B"}