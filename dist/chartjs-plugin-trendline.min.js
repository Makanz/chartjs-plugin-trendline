!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.chartjsPluginTrendline=e():t.chartjsPluginTrendline=e()}(this,(()=>(()=>{"use strict";var t={d:(e,i)=>{for(var s in i)t.o(i,s)&&!t.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:i[s]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{default:()=>n});class i{constructor(){this.count=0,this.sumx=0,this.sumy=0,this.sumx2=0,this.sumxy=0,this.minx=Number.MAX_VALUE,this.maxx=Number.MIN_VALUE,this._cachedSlope=null,this._cachedIntercept=null,this._cacheValid=!1}add(t,e){this.sumx+=t,this.sumy+=e,this.sumx2+=t*t,this.sumxy+=t*e,t<this.minx&&(this.minx=t),t>this.maxx&&(this.maxx=t),this.count++,this._cacheValid=!1}slope(){return this._cacheValid||this._computeCoefficients(),this._cachedSlope}intercept(){return this._cacheValid||this._computeCoefficients(),this._cachedIntercept}f(t){return this.slope()*t+this.intercept()}fo(){return-this.intercept()/this.slope()}scale(){return this.slope()}_computeCoefficients(){const t=this.count*this.sumx2-this.sumx*this.sumx;this._cachedSlope=(this.count*this.sumxy-this.sumx*this.sumy)/t,this._cachedIntercept=(this.sumy-this._cachedSlope*this.sumx)/this.count,this._cacheValid=!0}}class s{constructor(){this.count=0,this.sumx=0,this.sumlny=0,this.sumx2=0,this.sumxlny=0,this.minx=Number.MAX_VALUE,this.maxx=Number.MIN_VALUE,this.hasValidData=!0,this.dataPoints=[],this._cachedGrowthRate=null,this._cachedCoefficient=null,this._cachedCorrelation=null,this._cacheValid=!1}add(t,e){if(e<=0)return void(this.hasValidData=!1);const i=Math.log(e);isFinite(i)?(this.sumx+=t,this.sumlny+=i,this.sumx2+=t*t,this.sumxlny+=t*i,t<this.minx&&(this.minx=t),t>this.maxx&&(this.maxx=t),this.dataPoints.push({x:t,y:e,lny:i}),this.count++,this._cacheValid=!1):this.hasValidData=!1}growthRate(){return!this.hasValidData||this.count<2?0:(this._cacheValid||this._computeCoefficients(),this._cachedGrowthRate)}coefficient(){return!this.hasValidData||this.count<2?1:(this._cacheValid||this._computeCoefficients(),this._cachedCoefficient)}f(t){if(!this.hasValidData||this.count<2)return 0;if(this._cacheValid||this._computeCoefficients(),Math.abs(this._cachedGrowthRate*t)>500)return 0;const e=this._cachedCoefficient*Math.exp(this._cachedGrowthRate*t);return isFinite(e)?e:0}correlation(){return!this.hasValidData||this.count<2?0:(this._cacheValid||this._computeCoefficients(),this._cachedCorrelation)}scale(){return this.growthRate()}_computeCoefficients(){if(!this.hasValidData||this.count<2)return this._cachedGrowthRate=0,this._cachedCoefficient=1,this._cachedCorrelation=0,void(this._cacheValid=!0);const t=this.count*this.sumx2-this.sumx*this.sumx;if(Math.abs(t)<1e-10)return this._cachedGrowthRate=0,this._cachedCoefficient=1,this._cachedCorrelation=0,void(this._cacheValid=!0);this._cachedGrowthRate=(this.count*this.sumxlny-this.sumx*this.sumlny)/t;const e=(this.sumlny-this._cachedGrowthRate*this.sumx)/this.count;this._cachedCoefficient=Math.exp(e);const i=this.sumlny/this.count;let s=0,a=0;for(const t of this.dataPoints){const n=e+this._cachedGrowthRate*t.x;s+=Math.pow(t.lny-i,2),a+=Math.pow(t.lny-n,2)}this._cachedCorrelation=0===s?1:Math.max(0,1-a/s),this._cacheValid=!0}}const a={id:"chartjs-plugin-trendline",afterDatasetsDraw:t=>{const e=t.ctx,{xScale:a,yScale:n}=(t=>{let e,i;for(const s of Object.values(t.scales))if(s.isHorizontal()?e=s:i=s,e&&i)break;return{xScale:e,yScale:i}})(t);t.data.datasets.map(((t,e)=>({dataset:t,index:e}))).filter((t=>t.dataset.trendlineLinear||t.dataset.trendlineExponential)).sort(((t,e)=>{const i=t.dataset.order??0,s=e.dataset.order??0;return 0===i&&0!==s?1:0===s&&0!==i?-1:i-s})).forEach((({dataset:l,index:o})=>{if((l.alwaysShowTrendline||t.isDatasetVisible(o))&&l.data.length>1){((t,e,a,n,l)=>{const o=a.yAxisID||"y",h=t.controller.chart.scales[o]||l,r=!!a.trendlineExponential,c=a.trendlineExponential||a.trendlineLinear||{},d=a.borderColor||"rgba(169,169,169, .6)",{colorMin:u=d,colorMax:x=d,width:f=a.borderWidth||3,lineStyle:y="solid",fillColor:m=!1}=c;let p=c.trendoffset||0;const{color:g=d,text:_=(r?"Exponential Trendline":"Trendline"),display:b=!0,displayValue:V=!0,offset:w=10,percentage:F=!1}=c&&c.label||{},{family:C="'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:P=12}=c&&c.label&&c.label.font||{},M=t.controller.chart.options,N="object"==typeof M.parsing?M.parsing:void 0,D=c?.xAxisKey||N?.xAxisKey||"x",S=c?.yAxisKey||N?.yAxisKey||"y";let T=r?new s:new i;Math.abs(p)>=a.data.length&&(p=0);let v=0;if(p>0){const t=a.data.slice(p).findIndex((t=>null!=t));v=-1!==t?p+t:a.data.length}else{const t=a.data.findIndex((t=>null!=t));v=-1!==t?t:a.data.length}let L,A,j,E,G=v<a.data.length&&"object"==typeof a.data[v];if(a.data.forEach(((e,i)=>{if(null!=e&&!(p>0&&i<v||p<0&&i>=a.data.length+p))if(["time","timeseries"].includes(n.options.type)&&G){let t=null!=e[D]?e[D]:e.t;const i=e[S];null==t||void 0===t||null==i||isNaN(i)||T.add(new Date(t).getTime(),i)}else if(G){const t=e[D],i=e[S],s=null!=t&&!isNaN(t),a=null!=i&&!isNaN(i);s&&a&&T.add(t,i)}else if(["time","timeseries"].includes(n.options.type)&&!G){const s=t.controller.chart.data.labels;if(s&&s[i]&&null!=e&&!isNaN(e)){const t=new Date(s[i]).getTime();isNaN(t)||T.add(t,e)}}else null==e||isNaN(e)||T.add(i,e)})),T.count<2)return;const R=t.controller.chart.chartArea;if(c.projection){let t=[];if(r){const e=n.getValueForPixel(R.left),i=T.f(e);t.push({x:e,y:i});const s=n.getValueForPixel(R.right),a=T.f(s);t.push({x:s,y:a})}else{const e=T.slope(),i=T.intercept();if(Math.abs(e)>1e-6){const s=h.getValueForPixel(R.top),a=(s-i)/e;t.push({x:a,y:s});const n=h.getValueForPixel(R.bottom),l=(n-i)/e;t.push({x:l,y:n})}else t.push({x:n.getValueForPixel(R.left),y:i}),t.push({x:n.getValueForPixel(R.right),y:i});const s=n.getValueForPixel(R.left),a=T.f(s);t.push({x:s,y:a});const l=n.getValueForPixel(R.right),o=T.f(l);t.push({x:l,y:o})}const e=n.getValueForPixel(R.left),i=n.getValueForPixel(R.right),s=[h.getValueForPixel(R.top),h.getValueForPixel(R.bottom)].filter((t=>isFinite(t))),a=s.length>0?Math.min(...s):-1/0,l=s.length>0?Math.max(...s):1/0;let o=t.filter((t=>isFinite(t.x)&&isFinite(t.y)&&t.x>=e&&t.x<=i&&t.y>=a&&t.y<=l));o=o.filter(((t,e,i)=>e===i.findIndex((e=>Math.abs(e.x-t.x)<1e-4&&Math.abs(e.y-t.y)<1e-4)))),o.length>=2?(o.sort(((t,e)=>t.x-e.x||t.y-e.y)),L=n.getPixelForValue(o[0].x),A=h.getPixelForValue(o[0].y),j=n.getPixelForValue(o[o.length-1].x),E=h.getPixelForValue(o[o.length-1].y)):(L=NaN,A=NaN,j=NaN,E=NaN)}else{const t=T.f(T.minx),e=T.f(T.maxx);L=n.getPixelForValue(T.minx),A=h.getPixelForValue(t),j=n.getPixelForValue(T.maxx),E=h.getPixelForValue(e)}let I=null;if(isFinite(L)&&isFinite(A)&&isFinite(j)&&isFinite(E)&&(I=function(t,e,i,s,a){let n=i-t,l=s-e,o=0,h=1;const r=[-n,n,-l,l],c=[t-a.left,a.right-t,e-a.top,a.bottom-e];for(let t=0;t<4;t++)if(0===r[t]){if(c[t]<0)return null}else{const e=c[t]/r[t];if(r[t]<0){if(e>h)return null;o=Math.max(o,e)}else{if(e<o)return null;h=Math.min(h,e)}}return o>h?null:{x1:t+o*n,y1:e+o*l,x2:t+h*n,y2:e+h*l}}(L,A,j,E,R)),I)if(L=I.x1,A=I.y1,j=I.x2,E=I.y2,Math.abs(L-j)<.5&&Math.abs(A-E)<.5);else{e.lineWidth=f,((t,e)=>{switch(e){case"dotted":t.setLineDash([2,2]);break;case"dashed":t.setLineDash([8,3]);break;case"dashdot":t.setLineDash([8,3,2,3]);break;default:t.setLineDash([])}})(e,y),(({ctx:t,x1:e,y1:i,x2:s,y2:a,colorMin:n,colorMax:l})=>{if(isFinite(e)&&isFinite(i)&&isFinite(s)&&isFinite(a)){t.beginPath(),t.moveTo(e,i),t.lineTo(s,a);try{const o=s-e,h=a-i,r=Math.sqrt(o*o+h*h);if(r<.01)console.warn("Gradient vector too small, using solid color:",{x1:e,y1:i,x2:s,y2:a,length:r}),t.strokeStyle=n;else{let o=t.createLinearGradient(e,i,s,a);o.addColorStop(0,n),o.addColorStop(1,l),t.strokeStyle=o}}catch(e){console.warn("Gradient creation failed, using solid color:",e),t.strokeStyle=n}t.stroke(),t.closePath()}else console.warn("Cannot draw trendline: coordinates contain non-finite values",{x1:e,y1:i,x2:s,y2:a})})({ctx:e,x1:L,y1:A,x2:j,y2:E,colorMin:u,colorMax:x}),m&&((t,e,i,s,a,n,l)=>{isFinite(e)&&isFinite(i)&&isFinite(s)&&isFinite(a)&&isFinite(n)?(t.beginPath(),t.moveTo(e,i),t.lineTo(s,a),t.lineTo(s,n),t.lineTo(e,n),t.lineTo(e,i),t.closePath(),t.fillStyle=l,t.fill()):console.warn("Cannot fill below trendline: coordinates contain non-finite values",{x1:e,y1:i,x2:s,y2:a,drawBottom:n})})(e,L,A,j,E,R.bottom,m);const t=Math.atan2(E-A,j-L);if(c.label&&!1!==b){let i=_;if(V)if(r){const t=T.coefficient(),e=T.growthRate();i=`${_} (a=${t.toFixed(2)}, b=${e.toFixed(2)})`}else{const t=T.slope();i=`${_} (Slope: ${F?(100*t).toFixed(2)+"%":t.toFixed(2)})`}((t,e,i,s,a,n,l,o,h,r,c)=>{t.font=`${r}px ${h}`,t.fillStyle=o;const d=t.measureText(e).width,u=(i+a)/2,x=(s+n)/2;t.save(),t.translate(u,x),t.rotate(l);const f=-d/2,y=c;t.fillText(e,f,y),t.restore()})(e,i,L,A,j,E,t,g,C,P,w)}}})(t.getDatasetMeta(o),e,l,a,n)}})),e.setLineDash([])},beforeInit:t=>{t.data.datasets.forEach((e=>{const i=e.trendlineLinear||e.trendlineExponential;if(i&&i.label){const s=i.label,a=t.legend.options.labels.generateLabels;t.legend.options.labels.generateLabels=function(t){const n=a(t),l=i.legend;return l&&!1!==l.display&&n.push({text:l.text||s+" (Trendline)",strokeStyle:l.color||e.borderColor||"rgba(169,169,169, .6)",fillStyle:l.fillStyle||"transparent",lineCap:l.lineCap||"butt",lineDash:l.lineDash||[],lineWidth:l.width||1}),n}}}))}};"undefined"!=typeof window&&window.Chart&&(window.Chart.hasOwnProperty("register")?window.Chart.register(a):window.Chart.plugins.register(a));const n=a;return e.default})()));